# 实现 Outlet

Outlet 元素的基本使用：

1. 使用在嵌套 Route 的 element 中
2. 在父 Route 当中用作标记组件
3. 子 Route 会在父 Route 标记 Outlet 的地方渲染

## 源码思路

1. Outlet: 需要跨组件传值，将上层组件的 children 展示出来

   ```jsx
   export default function Outlet(props) {
     return useOutlet();
   }
   ```

2. hooks

   1. useRoutes 做多层级匹配，处理嵌套 Route 的展示

      ```jsx
      return routes.map((route) => {
        // 处理顶层路由，match以当前的路径开头
        const match = pathname.startsWith(route.path);
        return (
          {/* match的时候对嵌套路由进行处理，通过map决定渲染嵌套子路由的哪一个 */}
          match && route.children.map((child) => {
            let m = normalizePathname(child.path) === pathname;
            return (
              {/* 能匹配上的时候当前这个路由要继续作为嵌套路由，共享context向下传递 */}
              m && (
                <RouteContext.Provider
                  value={{ outlet: child.element }}
                  children={route.element !== undefined ? route.element : <Outlet />}
                    />
                  )
                );
              })
            );
          });
        }
      ```

   2. useOutlet: 将上层共享过来的 context，实际包含的就是 react 元素返回

## location 的补充

1. 目前 mini-react 在 useRoutes 中使用的还是 window 上的 location
2. 应该使用该组件本身的 location
3. hooks: useRoutes 中使用当前组件上层共享的 location

   ```jsx
   function useRoutes(routes) {
     const location = useLocation();
     const pathname = location.pathname;
     // .....
   }
   function useLocation() {
     const { location } = React.useContext(NavigationContext);
     return location;
   }
   ```

4. BrowserRouter: 将 location 作为 props 向下传递

   ```jsx
   function BrowserRouter({ children }) {
     const [state, setState] = React.useState({ location: history.location });
     React.useLayoutEffect(() => {
       history.listen(setState);
     }, [history]);
     return (
       <Router
         children={children}
         navigator={history}
         location={state.location}
       />
     );
   }
   ```

5. Router: 将 location 作为 context 暴露给后代组件

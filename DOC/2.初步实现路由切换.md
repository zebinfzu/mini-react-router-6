# 初步实现路由切换

本节要实现的内容：

1. 查看源文件 src/2.App.jsx
2. react-router 当中可以使用 Link 或者 NavLink 标签来改变当前的路径
3. 当路径变化的时候渲染的内容会改变
4. 本身 Route 标签的子节点不会渲染，除非 Route 标签本身的 element 中使用 Outlet 标签（本节还没实现 Outlet）

源码逻辑：

1. useNavigate，一个 hook 函数，返回一个函数，可以根据给定的 url 路径实现跳转

   ```jsx
   // 路由跳转函数
   export function useNavigate() {
     // 由于要跨组件传值，因此要使用useContext
     const { navigator } = useContext(NavigationContext);
     return navigator.push;
   }
   ```

2. Link.js 实际渲染出来的是 a 标签

   ```jsx
   import { useNavigate } from "./hooks";
   export default function Link({ to, children }) {
     // Link本身作为React对象，通过对象接构语法拿到to，children属性
     const navigate = useNavigate();

     const handleClick = (e) => {
       // 阻止a标签的原生事件
       e.preventDefault();
       // 跳转
       navigate(to);
     };
     return <a onClick={handleClick}>{children}</a>;
   }
   ```

3. createRoutesFromChildren.js 将原来通过 children 创建 routes 的过程从 routes.js 里面抽出来，并添加嵌套路由的处理

   ```jsx
   // 类比DOM->V-DOM，使用一个route对象来描述routes数组
   export default function createRoutesFromChildren(children) {
     const routes = [];
     React.Children.forEach(children, (child) => {
       const route = {
         element: child.props.element,
         path: child.props.path,
       };
       // 处理嵌套路由
       if (child.props.children) {
         route.children = createRoutesFromChildren(child.props.children);
       }
       routes.push(route);
     });
     return routes;
   }
   ```

4. Context.js 提供跨组件共享的 context

   ```jsx
   import { createContext } from "react";

   const NavigationContext = createContext();

   export { NavigationContext };
   ```

5. Router.js 为了适配使用不同的模式，所以要单独抽离出来 Router，向下传递数据

   ```jsx
   import { NavigationContext } from "./Context";

   // 跨组件层级传递数据 context
   export default function Router({ navigator, children }) {
     let navigationContext = { navigator };
     return (
       <NavigationContext.Provider value={navigationContext}>
         {children}
       </NavigationContext.Provider>
     );
   }
   ```

6. BrowserRouter.js 现在应该返回 Router 组件，每种模式都有自身的处理

   ```jsx
   import { createBrowserHistory } from "history";
   import { useRef } from "react";

   import Router from "./Router";

   export default function BrowserRouter({ children }) {
     // 存值，在组件卸载前，这个值在组件任何一个生命周期都指向同一个地址
     let historyRef = useRef();
     if (historyRef.current == null) {
       historyRef.current = createBrowserHistory();
     }

     let history = historyRef.current;

     return <Router children={children} navigator={history} />;
   }
   ```
